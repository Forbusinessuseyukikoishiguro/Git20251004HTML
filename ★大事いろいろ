"""
====================================
🐰 Python継承 完全ガイド
実行可能なサンプルコード
====================================

このコードをコピーして実行すると、
3種類の継承が学べます！
"""

print("="*70)
print("🐰 Python継承の学習を始めます！")
print("="*70)
print()

# ====================================
# 第1部: 単一継承
# ====================================
print("\n" + "="*70)
print("【第1部】単一継承 - 1つの親から1つの子へ")
print("="*70)

# --------------------------------------------------
# ステップ1: 親クラスを定義
# --------------------------------------------------
class DaifukuShop:
    """
    大福店の基本クラス（親クラス）
    
    役割: すべての大福店の基本機能を提供
    """
    
    def __init__(self, owner_name, stock):
        """
        コンストラクタ - インスタンス作成時に自動実行される
        
        引数:
            owner_name (str): 店長の名前
            stock (int): 初期在庫数
        
        処理:
            1. 店長名をインスタンス変数に保存
            2. 在庫数をインスタンス変数に保存
            3. 累計販売数を0で初期化
        """
        # self = このインスタンス（このお店）自身を指す
        # self.変数名 = インスタンス変数（このお店専用の変数）
        self.owner_name = owner_name  # 引数の値をインスタンス変数に代入
        self.stock = stock            # 在庫数を保存
        self.sold = 0                 # 販売数は0から開始
        
        # 開店メッセージを表示
        print(f"🏪 {self.owner_name}店長の基本店舗を開店しました")
    
    def sell(self, quantity):
        """
        大福を販売するメソッド（親クラスの基本機能）
        
        引数:
            quantity (int): 販売する個数
        
        戻り値:
            bool: 販売成功ならTrue、失敗ならFalse
        
        処理:
            1. 在庫が足りるかチェック
            2. 足りなければFalseを返して終了
            3. 足りれば在庫を減らす
            4. 累計販売数を増やす
            5. Trueを返す
        """
        # if文で条件分岐
        # quantity > self.stock = 売る個数が在庫より多い
        if quantity > self.stock:
            # 在庫不足の場合
            print(f"❌ 在庫不足！（在庫: {self.stock}個、注文: {quantity}個）")
            return False  # Falseを返して関数を終了
        
        # 在庫を減らす
        # -= は「引き算して代入」の演算子
        # self.stock = self.stock - quantity と同じ意味
        self.stock -= quantity
        
        # 累計販売数を増やす
        # += は「足し算して代入」の演算子
        self.sold += quantity
        
        # 販売成功メッセージ
        print(f"💰 {quantity}個販売しました（残り在庫: {self.stock}個）")
        
        # 成功を示すTrueを返す
        return True
    
    def show_info(self):
        """
        店舗情報を表示するメソッド
        
        戻り値: なし
        
        処理:
            店長名、在庫数、累計販売数を表示
        """
        print(f"\n{'='*50}")
        print(f"🏪 店舗情報")
        print(f"   店長: {self.owner_name}")
        print(f"   在庫: {self.stock}個")
        print(f"   累計販売: {self.sold}個")
        print(f"{'='*50}\n")


# --------------------------------------------------
# ステップ2: 子クラスを定義（継承）
# --------------------------------------------------
class PremiumDaifukuShop(DaifukuShop):
    """
    プレミアム大福店クラス（子クラス）
    
    継承: DaifukuShopを継承
    構文: class 子クラス名(親クラス名):
    
    役割: 基本店舗の機能 + プレミアム機能
    """
    
    def __init__(self, owner_name, stock, vip_count):
        """
        コンストラクタ（子クラス版）
        
        引数:
            owner_name (str): 店長名
            stock (int): 初期在庫
            vip_count (int): VIP会員数（子クラス固有の引数）
        
        処理:
            1. 親クラスの__init__を呼び出す
            2. 子クラス固有の変数を初期化
        
        重要: super().__init__()を呼ばないと親の初期化がされない！
        """
        # super() = 親クラスを参照する特殊な関数
        # super().__init__() = 親クラスの__init__を呼び出す
        # これで owner_name, stock, sold が初期化される
        super().__init__(owner_name, stock)
        
        # 子クラス固有のインスタンス変数を追加
        # 親にはない、プレミアム店だけの情報
        self.vip_count = vip_count
        
        # プレミアム店舗のメッセージ
        print(f"✨ プレミアム機能追加（VIP会員: {vip_count}名）")
    
    def sell_premium(self, quantity):
        """
        プレミアム販売（子クラス固有のメソッド）
        
        特徴: 通常価格の1.5倍で販売
        
        引数:
            quantity (int): 販売個数
        
        戻り値:
            bool: 販売成功ならTrue
        
        処理:
            1. 親のsellメソッドを呼び出す
            2. 成功したらプレミアム価格を表示
        """
        # 親クラスのsellメソッドを呼び出す
        # super().メソッド名() = 親のメソッドを使う
        result = super().sell(quantity)
        
        # if result: = resultがTrueなら実行
        if result:
            # プレミアム価格を計算
            # 150円 × 1.5 = 225円
            premium_price = quantity * 225
            
            # プレミアム販売メッセージ
            print(f"✨ プレミアム価格: ¥{premium_price}")
        
        # 結果を返す（TrueまたはFalse）
        return result
    
    def add_vip(self, count=1):
        """
        VIP会員を追加（子クラス固有のメソッド）
        
        引数:
            count (int): 追加する会員数（デフォルト値は1）
        
        デフォルト引数: count=1 という書き方
            呼び出し時に引数を省略すると1が使われる
        """
        # VIP会員数を増やす
        self.vip_count += count
        
        # 追加メッセージ
        print(f"👑 VIP会員が{count}名増えました（合計: {self.vip_count}名）")
    
    def show_info(self):
        """
        店舗情報を表示（オーバーライド）
        
        オーバーライド: 親のメソッドを子で上書きすること
        
        処理:
            1. 親のshow_infoを呼んで基本情報を表示
            2. 子クラス固有のVIP情報を追加表示
        """
        # 親クラスのshow_infoを呼び出す
        # これで店長名、在庫、販売数が表示される
        super().show_info()
        
        # 子クラス固有の情報を追加
        print(f"👑 VIP会員: {self.vip_count}名")
        print(f"{'='*50}\n")


# --------------------------------------------------
# ステップ3: 単一継承を使ってみる
# --------------------------------------------------
print("\n【デモ1】親クラスを使う")
print("-"*70)

# 親クラスのインスタンスを作成
# クラス名(引数) でインスタンス化
basic = DaifukuShop("うさうさ", 20)
# 出力: 🏪 うさうさ店長の基本店舗を開店しました

# 親クラスのメソッドを呼び出す
basic.sell(5)
# 出力: 💰 5個販売しました（残り在庫: 15個）

# 情報表示
basic.show_info()

print("\n【デモ2】子クラスを使う")
print("-"*70)

# 子クラスのインスタンスを作成
# 引数3つ必要: owner_name, stock, vip_count
premium = PremiumDaifukuShop("もちもち", 30, 5)
# 出力: 🏪 もちもち店長の基本店舗を開店しました
#       ✨ プレミアム機能追加（VIP会員: 5名）

# 親から継承したメソッドを使う
premium.sell(3)
# 出力: 💰 3個販売しました（残り在庫: 27個）

# 子クラス固有のメソッドを使う
premium.sell_premium(2)
# 出力: 💰 2個販売しました（残り在庫: 25個）
#       ✨ プレミアム価格: ¥450

# VIP会員を追加
premium.add_vip(2)
# 出力: 👑 VIP会員が2名増えました（合計: 7名）

# オーバーライドしたメソッドを使う
premium.show_info()


# ====================================
# 第2部: 階層継承
# ====================================
print("\n" + "="*70)
print("【第2部】階層継承 - 親→子→孫と続く継承")
print("="*70)

# --------------------------------------------------
# 孫クラスを定義（階層継承）
# --------------------------------------------------
class VIPDaifukuShop(PremiumDaifukuShop):
    """
    VIP専門大福店クラス（孫クラス）
    
    継承: PremiumDaifukuShopを継承
    継承チェーン: DaifukuShop → PremiumDaifukuShop → VIPDaifukuShop
    
    役割: プレミアム店舗の機能 + VIP専門機能
    
    注意: 父を継承すると、自動的に祖父も継承される
    """
    
    def __init__(self, owner_name, stock, vip_count, concierge_count):
        """
        コンストラクタ（孫クラス版）
        
        引数:
            owner_name (str): 店長名
            stock (int): 初期在庫
            vip_count (int): VIP会員数
            concierge_count (int): コンシェルジュ数（孫クラス固有）
        
        処理:
            1. 父クラス(PremiumDaifukuShop)の__init__を呼ぶ
               → その中で祖父クラス(DaifukuShop)の__init__も呼ばれる
            2. 孫クラス固有の変数を初期化
        
        継承の連鎖:
            孫のsuper().__init__()
            → 父のsuper().__init__()
            → 祖父の__init__()
            全部自動的に実行される！
        """
        # super()で父クラス(PremiumDaifukuShop)の__init__を呼ぶ
        # 父の中で祖父の__init__も呼ばれるので、3世代全部初期化される
        super().__init__(owner_name, stock, vip_count)
        
        # 孫クラス固有のインスタンス変数
        self.concierge_count = concierge_count
        
        # VIP専門店のメッセージ
        print(f"👑 VIP専門店機能追加（コンシェルジュ: {concierge_count}名）")
    
    def sell_vip_exclusive(self, quantity):
        """
        VIP限定販売（孫クラス固有のメソッド）
        
        特徴: プレミアム価格の2倍（超高級）
        
        引数:
            quantity (int): 販売個数
        
        戻り値:
            bool: 販売成功ならTrue
        
        処理:
            1. 父のsell_premiumメソッドを呼ぶ
               → その中で祖父のsellメソッドも呼ばれる
            2. 成功したらVIP限定価格を表示
        """
        # 父クラス(PremiumDaifukuShop)のsell_premiumを呼ぶ
        # sell_premiumの中で祖父のsellが呼ばれる
        # つまり: 孫 → 父 → 祖父 のメソッド連鎖
        result = super().sell_premium(quantity)
        
        # 販売に成功した場合
        if result:
            # VIP限定価格を計算
            # 225円 × 2 = 450円
            vip_price = quantity * 450
            
            # VIP限定販売メッセージ
            print(f"👑 VIP限定価格: ¥{vip_price}")
            print(f"📞 コンシェルジュがお届けします")
        
        # 結果を返す
        return result
    
    def concierge_service(self):
        """
        コンシェルジュサービス（孫クラス固有のメソッド）
        
        処理:
            サービス内容を表示
        """
        print(f"\n👔 コンシェルジュサービス")
        print(f"   専任スタッフ: {self.concierge_count}名")
        print(f"   VIP会員様: {self.vip_count}名")
        print(f"   お一人様あたり専任コンシェルジュが対応します\n")
    
    def show_info(self):
        """
        店舗情報を表示（さらにオーバーライド）
        
        処理:
            1. 父のshow_infoを呼ぶ
               → 父の中で祖父のshow_infoも呼ばれる
            2. 孫クラス固有の情報を追加
        """
        # 父クラスのshow_infoを呼ぶ
        # これで祖父+父の情報が全部表示される
        super().show_info()
        
        # 孫クラス固有の情報を追加
        print(f"👔 コンシェルジュ: {self.concierge_count}名")
        print(f"{'='*50}\n")


# --------------------------------------------------
# 階層継承を使ってみる
# --------------------------------------------------
print("\n【デモ3】孫クラスを使う")
print("-"*70)

# 孫クラスのインスタンスを作成
# 引数4つ必要: owner_name, stock, vip_count, concierge_count
vip = VIPDaifukuShop("ぴょんぴょん", 40, 10, 3)
# 出力: 🏪 ぴょんぴょん店長の基本店舗を開店しました
#       ✨ プレミアム機能追加（VIP会員: 10名）
#       👑 VIP専門店機能追加（コンシェルジュ: 3名）

# 祖父クラスから継承したメソッド
vip.sell(2)

# 父クラスから継承したメソッド
vip.sell_premium(3)
vip.add_vip(1)

# 孫クラス固有のメソッド
vip.sell_vip_exclusive(1)
vip.concierge_service()

# オーバーライドしたメソッド（全情報表示）
vip.show_info()

# 継承チェーンを確認
print("【継承チェーン（MRO: Method Resolution Order）】")
print("メソッドを探す順番:")
# __mro__ = メソッド解決順序を示すタプル
# クラス.__mro__ で継承の順序がわかる
for i, cls in enumerate(VIPDaifukuShop.__mro__, 1):
    # enumerate(リスト, 開始番号) = インデックス付きでループ
    # cls.__name__ = クラス名を取得
    print(f"  {i}. {cls.__name__}")
# 出力: VIPDaifukuShop → PremiumDaifukuShop → DaifukuShop → object
print()


# ====================================
# 第3部: 多重継承
# ====================================
print("\n" + "="*70)
print("【第3部】多重継承 - 複数の親クラスから機能を組み合わせ")
print("="*70)

# --------------------------------------------------
# 4つの独立した親クラスを定義
# --------------------------------------------------

# 親クラスA: 基本店舗機能
class ShopBase:
    """
    店舗の基本機能（多重継承用の親A）
    
    役割: 店舗としての基本的な販売機能
    """
    
    def __init__(self, owner_name, stock):
        """
        コンストラクタ（親A）
        
        引数:
            owner_name (str): 店長名
            stock (int): 在庫数
        """
        self.owner_name = owner_name
        self.stock = stock
        self.sold = 0
        print(f"🏪 店舗機能: {owner_name}店長")
    
    def sell(self, quantity):
        """基本的な販売処理"""
        if quantity > self.stock:
            print(f"❌ 在庫不足")
            return False
        self.stock -= quantity
        self.sold += quantity
        print(f"💰 {quantity}個販売")
        return True


# 親クラスB: オンライン機能
class OnlineServiceMixin:
    """
    オンライン注文機能（多重継承用の親B）
    
    役割: オンラインでの注文受付機能
    
    Mixin: 機能追加専用のクラス
           単独では使わず、他のクラスと組み合わせて使う
    """
    
    def __init__(self):
        """
        コンストラクタ（親B）
        
        注意: 引数なし（機能だけを提供）
        """
        self.online_orders = 0  # オンライン注文の累計
        print(f"🌐 オンライン機能: システム起動")
    
    def receive_online_order(self, customer, quantity):
        """
        オンライン注文を受け付ける
        
        引数:
            customer (str): 顧客名
            quantity (int): 注文個数
        """
        self.online_orders += 1
        print(f"🌐 オンライン注文 #{self.online_orders}")
        print(f"   顧客: {customer}様、数量: {quantity}個")


# 親クラスC: 配達機能
class DeliveryServiceMixin:
    """
    配達サービス機能（多重継承用の親C）
    
    役割: 商品の配達機能
    """
    
    def __init__(self):
        """コンストラクタ（親C）"""
        self.deliveries = 0  # 配達の累計回数
        print(f"🚚 配達機能: サービス開始")
    
    def deliver(self, address):
        """
        商品を配達する
        
        引数:
            address (str): 配達先住所
        """
        self.deliveries += 1
        print(f"🚚 配達 #{self.deliveries}: {address}へ配達中")


# 親クラスD: 会員機能
class MembershipServiceMixin:
    """
    会員サービス機能（多重継承用の親D）
    
    役割: 会員の登録と管理
    """
    
    def __init__(self):
        """コンストラクタ（親D）"""
        self.members = []  # 会員名のリスト
        print(f"💳 会員機能: システム起動")
    
    def register_member(self, name):
        """
        会員を登録する
        
        引数:
            name (str): 会員名
        """
        # append() = リストに要素を追加するメソッド
        self.members.append(name)
        # len() = リストの長さを取得する関数
        print(f"💳 {name}様を会員登録（会員数: {len(self.members)}名）")
    
    def is_member(self, name):
        """
        会員かどうかチェック
        
        引数:
            name (str): チェックする名前
        
        戻り値:
            bool: 会員ならTrue
        """
        # in演算子 = リストに要素が含まれているかチェック
        return name in self.members


# --------------------------------------------------
# 子クラス: 多重継承で4つの機能を統合
# --------------------------------------------------
class HybridDaifukuShop(ShopBase, OnlineServiceMixin, 
                        DeliveryServiceMixin, MembershipServiceMixin):
    """
    ハイブリッド大福店（多重継承）
    
    継承元（カッコ内に複数の親をカンマ区切りで列挙）:
    - ShopBase（店舗機能）
    - OnlineServiceMixin（オンライン機能）
    - DeliveryServiceMixin（配達機能）
    - MembershipServiceMixin（会員機能）
    
    役割: すべての機能を統合した最先端店舗
    
    多重継承の構文:
        class 子クラス名(親A, 親B, 親C, 親D):
    
    注意点:
        - 全ての親を初期化する必要がある
        - super()だけでは不十分（複数親なので）
        - 親名.__init__(self, ...) の形式で直接呼ぶ
    """
    
    def __init__(self, owner_name, stock):
        """
        コンストラクタ（多重継承版）
        
        引数:
            owner_name (str): 店長名
            stock (int): 初期在庫
        
        重要: すべての親クラスを初期化する必要がある！
              一つでも忘れるとその機能が使えない
        """
        # 開始メッセージ
        print(f"\n{'='*60}")
        print(f"🌟 ハイブリッド店舗を起動中...")
        print(f"{'='*60}")
        
        # 各親クラスを初期化（順番に呼び出す）
        # 親クラス名.__init__(self, 引数) の形式
        # super()じゃなくて親名.__init__()を使う理由:
        #   複数の親があるので、どの親か明示する必要がある
        
        ShopBase.__init__(self, owner_name, stock)  # 親A初期化
        OnlineServiceMixin.__init__(self)  # 親B初期化
        DeliveryServiceMixin.__init__(self)  # 親C初期化
        MembershipServiceMixin.__init__(self)  # 親D初期化
        
        # 完了メッセージ
        print(f"✅ すべての機能が利用可能です")
        print(f"{'='*60}\n")
    
    def process_order(self, customer, quantity, address, is_member=False):
        """
        統合注文処理（すべての機能を組み合わせ）
        
        処理の流れ:
        1. オンライン注文受付（親Bの機能）
        2. 販売処理（親Aの機能）
        3. 配達処理（親Cの機能）
        4. 会員登録（親Dの機能）
        
        引数:
            customer (str): 顧客名
            quantity (int): 注文個数
            address (str): 配達先住所
            is_member (bool): 会員かどうか（デフォルトFalse）
        
        デフォルト引数: is_member=False
            呼び出し時に省略すると False が使われる
        """
        # 処理開始メッセージ
        print(f"\n{'='*60}")
        print(f"📝 注文処理開始: {customer}様")
        print(f"{'='*60}")
        
        # 1. オンライン注文受付（親Bのメソッド）
        # self.receive_online_order() = 親Bから継承したメソッド
        self.receive_online_order(customer, quantity)
        
        # 2. 販売処理（親Aのメソッド）
        # self.sell() = 親Aから継承したメソッド
        if self.sell(quantity):
            # 販売成功の場合
            
            # 3. 配達処理（親Cのメソッド）
            # self.deliver() = 親Cから継承したメソッド
            self.deliver(address)
            
            # 4. 会員登録処理（親Dのメソッド）
            # is_memberがTrueで、まだ登録されていない場合
            # and演算子 = 両方Trueなら実行
            # not演算子 = Trueの否定（Falseにする）
            if is_member and not self.is_member(customer):
                # self.register_member() = 親Dから継承したメソッド
                self.register_member(customer)
            
            # 成功メッセージ
            print(f"✅ 注文処理完了")
        else:
            # 販売失敗の場合
            print(f"❌ 注文処理失敗")
        
        # 処理終了メッセージ
        print(f"{'='*60}\n")
    
    def show_all_stats(self):
        """
        すべての統計情報を表示
        
        処理:
            4つの親から継承した全変数を表示
        """
        print(f"\n{'='*60}")
        print(f"📊 ハイブリッド店舗 総合統計")
        print(f"{'='*60}")
        
        # 店舗情報（親Aから継承した変数）
        print(f"🏪 店長: {self.owner_name}")
        print(f"📦 在庫: {self.stock}個")
        print(f"💰 累計販売: {self.sold}個")
        
        # オンライン情報（親Bから継承した変数）
        print(f"🌐 オンライン注文: {self.online_orders}件")
        
        # 配達情報（親Cから継承した変数）
        print(f"🚚 配達回数: {self.deliveries}回")
        
        # 会員情報（親Dから継承した変数）
        print(f"💳 会員数: {len(self.members)}名")
        
        # 区切り線
        print(f"{'='*60}\n")


# --------------------------------------------------
# 多重継承を使ってみる
# --------------------------------------------------
print("\n【デモ4】多重継承 - ハイブリッド店舗")
print("-"*70)
hybrid = HybridDaifukuShop("ふわふわ", 50)



# MRO（メソッド探索順）を確認
print("\n【MRO確認】")
for i, cls in enumerate(HybridDaifukuShop.__mro__, 1):
    print(f"  {i}. {cls.__name__}")


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#オーバーライド
# class Parent:
#     def greet(self):
#         print("こんにちは、親クラスです！")

# class Child(Parent):
#     def greet(self):  # 親の greet を上書き
#         print("こんにちは、子クラスです！")

# c = Child()
# c.greet()

class Parent:
    def greet(self):
        print("こんにちは、親クラスです！")

class Child(Parent):
    def greet(self):
        print("子クラスの挨拶前処理")
        super().greet()  # 親クラスのメソッドを呼ぶ
        print("子クラスの挨拶後処理")

c = Child()
c.greet()


＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
# ====================================
# ふわふわ大福店シリーズ：クラスと継承の例
# GoogleスタイルDocstring付き
# ====================================

# ① 親子クラス（単一継承）
class Parent:
    """親クラスの例"""
    def greet(self):
        """親クラスの挨拶メソッド"""
        print("こんにちは！私は親クラスです。")

class Child(Parent):
    """親クラスを継承した子クラス"""
    def greet_child(self):
        """子クラス専用の挨拶"""
        print("私は子クラスです！")

# テスト
c = Child()
c.greet()        # 親のメソッド
c.greet_child()  # 子のメソッド


# ② 階層継承（親→子→孫）
class GrandParent:
    """祖父母クラス"""
    def say(self):
        """祖父母の挨拶"""
        print("祖父母クラスです。")

class Parent2(GrandParent):
    """親クラス"""
    def say_parent(self):
        print("親クラスです。")

class Child2(Parent2):
    """子クラス"""
    def say_child(self):
        print("子クラスです。")

# テスト
c2 = Child2()
c2.say()
c2.say_parent()
c2.say_child()


# ③ 多重継承（複数の親を持つ）
class A:
    def hello(self):
        print("Aクラスからこんにちは")

class B:
    def hello(self):
        print("Bクラスからこんにちは")

class C(A, B):
    """AとBを継承（左側優先）"""
    pass

c3 = C()
c3.hello()  # Aが優先される


# ④ __init__（初期化）
class Shop:
    """お店クラスの例"""
    def __init__(self, name):
        """
        インスタンス生成時に名前を初期化

        Args:
            name (str): お店の名前
        """
        self.name = name
        print(f"{self.name}を開店しました！")

shop = Shop("ふわふわ大福店")


# ⑤ super()（親の処理を呼ぶ）
class ParentInit:
    """親クラスの初期化"""
    def __init__(self):
        print("親クラスの初期化")

class ChildInit(ParentInit):
    """子クラスの初期化"""
    def __init__(self):
        super().__init__()  # 親の初期化を呼ぶ
        print("子クラスの初期化")

c_init = ChildInit()


# ⑦ 特殊メソッド
class Daifuku:
    """大福クラス"""
    def __init__(self, flavor):
        """
        Args:
            flavor (str): 大福の味
        """
        self.flavor = flavor

    def __str__(self):
        """文字列表示"""
        return f"🍡 {self.flavor}大福です"

d = Daifuku("あんこ")
print(d)


# ⑧ クラス変数と⑨ インスタンス変数
class Shop2:
    tax_rate = 0.1  # クラス変数（全員で共有）

    def __init__(self, name):
        self.name = name  # インスタンス変数（個別）

s1 = Shop2("もちもち店")
s2 = Shop2("ぴょんぴょん店")
print(f"{s1.name}の税率: {s1.tax_rate}, {s2.name}の税率: {s2.tax_rate}")


# ⑩ メソッド
class Shop3:
    """販売メソッド"""
    def sell(self, num):
        """
        商品を販売する

        Args:
            num (int): 販売する個数
        """
        print(f"🍡 {num}個販売しました！")

s3 = Shop3()
s3.sell(5)


# ⑪ self
class Shop4:
    """selfの例"""
    def __init__(self, name):
        self.name = name

    def greet(self):
        """インスタンス変数を使った挨拶"""
        print(f"{self.name}へようこそ！")

s4 = Shop4("ふわふわ大福店")
s4.greet()


# ⑫ *args, **kwargs（可変長引数）
class Menu:
    """メニュークラス"""
    def show_items(self, *args, **kwargs):
        """
        可変長引数の例

        Args:
            *args: 商品名のタプル
            **kwargs: 商品と価格の辞書
        """
        print("商品リスト:", args)
        print("価格表:", kwargs)

m = Menu()
m.show_items("あんこ", "いちご", "クリーム", あんこ=150, いちご=200)

#oyakotestsimple.py


＃＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
# 【初心者向け】Python基本の8つのデータ型完全ガイド

Pythonプログラミングで必ず押さえておくべき8つの基本データ型を徹底解説します。

## 目次
1. [int（整数型）](#int整数型)
2. [float（浮動小数点数型）](#float浮動小数点数型)
3. [str（文字列型）](#str文字列型)
4. [list（リスト型）](#listリスト型)
5. [tuple（タプル型）](#tupleタプル型)
6. [dict（辞書型）](#dict辞書型)
7. [set（集合型）](#set集合型)
8. [bool（ブール型）](#boolブール型)
9. [型変換と注意点](#型変換と注意点)

---

## int（整数型）

整数を扱うデータ型です。Pythonのintは任意精度なので、桁数の制限がありません。

### 基本的な使い方

```python
# 基本
age = 25
count = -10
big_number = 1_000_000  # アンダースコアで読みやすく（実際の値は1000000）

# 演算
result = 10 + 5  # 15（加算）
result = 10 - 3  # 7（減算）
result = 10 * 2  # 20（乗算）
result = 10 // 3  # 3（整数除算）
result = 10 % 3  # 1（剰余）
result = 2 ** 8  # 256（べき乗）
```

### よく使う操作

```python
# 絶対値
abs(-10)  # 10

# 累乗
pow(2, 3)  # 8

# 最大値・最小値
max(1, 5, 3)  # 5
min(1, 5, 3)  # 1

# 型チェック
isinstance(10, int)  # True
type(10)  # <class 'int'>
```

---

## float（浮動小数点数型）

小数を扱うデータ型です。

### 基本的な使い方

```python
# 基本
price = 99.99
temperature = -15.5
pi = 3.14159

# 科学的記法
small = 1.5e-3  # 0.0015
large = 2.5e6   # 2500000.0

# 演算
result = 10.5 + 2.3  # 12.8
result = 10.0 / 3.0  # 3.3333...
```

### よく使う操作

```python
# 四捨五入
round(3.14159, 2)  # 3.14

# 切り上げ・切り捨て
import math
math.ceil(3.2)   # 4
math.floor(3.8)  # 3

# 絶対値
abs(-10.5)  # 10.5

# 平方根
math.sqrt(16)  # 4.0
```

### 注意点：浮動小数点数の誤差

```python
# ⚠️ 浮動小数点数の誤差
0.1 + 0.2  # 0.30000000000000004

# ✅ 正確な比較が必要な場合
from decimal import Decimal
Decimal('0.1') + Decimal('0.2')  # Decimal('0.3')
```

---

## str（文字列型）

テキストデータを扱うデータ型です。イミュータブル（変更不可）です。

### 基本的な使い方

```python
# 基本
name = "太郎"
message = 'Hello, World!'

# 複数行
multiline = """これは
複数行の
文字列です"""

# 文字列の連結
greeting = "Hello, " + "World!"
full_name = "山田" + " " + "太郎"

# 繰り返し
repeat = "ABC" * 3  # "ABCABCABC"
```

### f-string（フォーマット済み文字列）

```python
# f-string（Python 3.6+、推奨）
name = "太郎"
age = 25
message = f"{name}は{age}歳です"
message = f"{name}は来年{age + 1}歳になります"

# 小数点の桁数指定
price = 1234.5
f"価格: ¥{price:,.2f}"  # "価格: ¥1,234.50"
```

### よく使う操作

```python
text = "Hello World"

# 長さ
len(text)  # 11

# 大文字・小文字
text.upper()  # "HELLO WORLD"
text.lower()  # "hello world"
text.capitalize()  # "Hello world"

# 検索
text.find("World")  # 6（インデックス）
"World" in text  # True
text.count("o")  # 2

# 置換
text.replace("World", "Python")  # "Hello Python"

# 分割・結合
words = text.split()  # ['Hello', 'World']
"-".join(words)  # "Hello-World"

# 前後の空白削除
"  Hello  ".strip()  # "Hello"
```

### インデックスとスライス

```python
text = "Python"

# インデックス
text[0]   # 'P'
text[-1]  # 'n'（最後）

# スライス [start:end:step]
text[0:3]   # 'Pyt'
text[:3]    # 'Pyt'（先頭から）
text[3:]    # 'hon'（最後まで）
text[::2]   # 'Pto'（2文字おき）
text[::-1]  # 'nohtyP'（反転）
```

---

## list（リスト型）

順序を持つ、変更可能なコレクション型です。Pythonで最もよく使われるデータ型の一つです。

### 基本的な作成

```python
# 基本
fruits = ["りんご", "バナナ", "みかん"]
numbers = [1, 2, 3, 4, 5]
mixed = [1, "text", True, 3.14, None]  # 異なる型も混在可

# 空のリスト
empty = []
empty = list()

# 範囲からリストを作成
numbers = list(range(5))  # [0, 1, 2, 3, 4]
numbers = list(range(1, 6))  # [1, 2, 3, 4, 5]
```

### 要素の追加

```python
fruits = ["りんご", "バナナ"]

# 末尾に1つ追加
fruits.append("みかん")
# ['りんご', 'バナナ', 'みかん']

# 指定位置に追加
fruits.insert(0, "いちご")  # 先頭に追加
fruits.insert(2, "メロン")  # インデックス2に追加

# 複数追加
fruits.extend(["ぶどう", "桃"])
fruits += ["梨", "柿"]

# リスト同士の結合
list1 = [1, 2, 3]
list2 = [4, 5, 6]
combined = list1 + list2  # [1, 2, 3, 4, 5, 6]
```

### 要素の削除

```python
fruits = ["りんご", "バナナ", "みかん", "いちご"]

# 値で削除（最初に見つかったものを削除）
fruits.remove("バナナ")

# インデックスで削除
del fruits[0]

# 末尾を削除して取得
last = fruits.pop()  # "いちご"を削除して返す
second = fruits.pop(1)  # インデックス1を削除して返す

# すべて削除
fruits.clear()
```

### 要素へのアクセス

```python
fruits = ["りんご", "バナナ", "みかん", "いちご", "ぶどう"]

# インデックスでアクセス
first = fruits[0]   # "りんご"
last = fruits[-1]   # "ぶどう"

# スライス [start:end:step]
subset = fruits[1:3]   # ['バナナ', 'みかん']
first_three = fruits[:3]  # ['りんご', 'バナナ', 'みかん']
every_other = fruits[::2]  # ['りんご', 'みかん', 'ぶどう']

# 要素の変更
fruits[0] = "メロン"
fruits[1:3] = ["桃", "梨"]  # 複数要素を一度に変更
```

### よく使う操作

```python
numbers = [3, 1, 4, 1, 5, 9, 2, 6]

# 長さ
len(numbers)  # 8

# 出現回数
numbers.count(1)  # 2

# インデックス取得
numbers.index(5)  # 4

# 存在確認
4 in numbers  # True

# 最大値・最小値・合計
max(numbers)  # 9
min(numbers)  # 1
sum(numbers)  # 31

# ソート
numbers.sort()  # リストを直接変更
sorted_nums = sorted(numbers)  # 新しいリストを返す

# 降順ソート
numbers.sort(reverse=True)

# 反転
numbers.reverse()  # リストを直接変更
```

### リスト内包表記

```python
# 基本
squares = [x**2 for x in range(10)]
# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 条件付き
evens = [x for x in range(20) if x % 2 == 0]
# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

# if-else
labels = ["正" if x > 0 else "負" for x in [-1, 2, -3, 4]]
# ['負', '正', '負', '正']

# ネストしたループ
pairs = [(x, y) for x in range(3) for y in range(3)]
# [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,0), (2,1), (2,2)]
```

### ループ処理

```python
fruits = ["りんご", "バナナ", "みかん"]

# 基本的なループ
for fruit in fruits:
    print(fruit)

# インデックス付きループ
for i, fruit in enumerate(fruits):
    print(f"{i}: {fruit}")

# 複数リストを同時にループ
names = ["太郎", "花子", "次郎"]
ages = [25, 23, 30]
for name, age in zip(names, ages):
    print(f"{name}は{age}歳")
```

### 注意点

```python
# ⚠️ コピーの罠
list1 = [1, 2, 3]
list2 = list1  # 参照のコピー
list2.append(4)
print(list1)  # [1, 2, 3, 4] - list1も変わる！

# ✅ 正しいコピー
list2 = list1.copy()
list2 = list1[:]
list2 = list(list1)

# ⚠️ ループ中の削除は危険
numbers = [1, 2, 3, 4, 5]
# ❌ 間違い
for num in numbers:
    if num % 2 == 0:
        numbers.remove(num)

# ✅ リスト内包表記を使う
numbers = [num for num in numbers if num % 2 != 0]
```

---

## tuple（タプル型）

順序を持つ、**変更不可能な**コレクション型です。リストと似ていますが、一度作成したら変更できません。

### 基本的な作成

```python
# 基本
coordinates = (10, 20)
rgb = (255, 0, 0)
person = ("太郎", 25, "東京")

# 1要素のタプル（カンマが必要！）
single = (1,)  # ✅ タプル
not_tuple = (1)  # ❌ これは整数の1

# 空のタプル
empty = ()
empty = tuple()

# カッコなしでも作成可能
point = 10, 20  # (10, 20)

# リストからタプルを作成
numbers = tuple([1, 2, 3, 4, 5])
```

### 要素へのアクセス

```python
point = (10, 20, 30)

# インデックスでアクセス
x = point[0]  # 10
z = point[-1]  # 30

# スライス
subset = point[0:2]  # (10, 20)
reversed_point = point[::-1]  # (30, 20, 10)

# アンパッキング（展開）
x, y, z = point
print(x, y, z)  # 10 20 30

# 一部だけ取得
first, *rest = (1, 2, 3, 4, 5)
# first = 1, rest = [2, 3, 4, 5]

*beginning, last = (1, 2, 3, 4, 5)
# beginning = [1, 2, 3, 4], last = 5

first, *middle, last = (1, 2, 3, 4, 5)
# first = 1, middle = [2, 3, 4], last = 5
```

### よく使う操作

```python
numbers = (1, 2, 3, 2, 1, 4)

# 長さ
len(numbers)  # 6

# 出現回数
numbers.count(2)  # 2

# インデックス取得
numbers.index(3)  # 2

# 存在確認
2 in numbers  # True

# 最大値・最小値・合計
max(numbers)  # 4
min(numbers)  # 1
sum(numbers)  # 13
```

### タプルの結合と繰り返し

```python
# 結合
tuple1 = (1, 2, 3)
tuple2 = (4, 5, 6)
combined = tuple1 + tuple2  # (1, 2, 3, 4, 5, 6)

# 繰り返し
repeated = (1, 2) * 3  # (1, 2, 1, 2, 1, 2)
```

### タプルとリストの使い分け

```python
# ✅ タプルを使うべき場面

# 1. 変更されるべきでないデータ
DATE_OF_BIRTH = (1990, 5, 15)  # 生年月日

# 2. 座標や色などの固定データ
position = (35.6762, 139.6503)  # 緯度経度
color = (255, 128, 0)  # RGB

# 3. 関数から複数の値を返す
def get_user_info():
    return "太郎", 25, "東京"

name, age, city = get_user_info()

# 4. 辞書のキーとして使用
locations = {
    (35.6762, 139.6503): "東京",
    (34.6937, 135.5023): "大阪"
}

# ✅ リストを使うべき場面

# 1. 要素を追加・削除する必要がある
tasks = ["買い物", "掃除"]
tasks.append("料理")

# 2. 要素を変更する必要がある
scores = [85, 90, 78]
scores[0] = 88

# 3. ソートが必要
numbers = [3, 1, 4, 1, 5]
numbers.sort()
```

### 注意点

```python
# ⚠️ タプルは変更不可
point = (10, 20, 30)
# point[0] = 15  # ❌ TypeError

# ⚠️ 1要素のタプルの落とし穴
not_tuple = (1)     # int型の1
is_tuple = (1,)     # tuple型の(1,)

# ⚠️ タプルのアンパッキング時の要素数
x, y = (1, 2, 3)  # ❌ ValueError: too many values

# ✅ *を使って残りをまとめる
x, *rest = (1, 2, 3)  # x=1, rest=[2, 3]
```

---

## dict（辞書型）

キーと値のペアでデータを管理する型です。高速な検索が特徴です。

### 基本的な使い方

```python
# 基本
student = {
    "name": "田中",
    "age": 20,
    "grade": "A"
}

# 別の作成方法
student = dict(name="田中", age=20, grade="A")

# 空の辞書
empty = {}
empty = dict()
```

### 追加・更新・削除

```python
student = {"name": "田中", "age": 20}

# 追加・更新
student["grade"] = "A"
student["age"] = 21

# 複数追加・更新
student.update({"city": "東京", "club": "テニス"})

# 削除
del student["city"]
age = student.pop("age")

# すべて削除
student.clear()
```

### 取得

```python
student = {"name": "田中", "age": 20, "grade": "A"}

# 直接アクセス
name = student["name"]  # "田中"

# getメソッド（推奨）
grade = student.get("grade")  # "A"
city = student.get("city")  # None
city = student.get("city", "未設定")  # デフォルト値

# キーの存在確認
if "age" in student:
    print(f"年齢: {student['age']}")

# すべてのキー・値・ペア
keys = student.keys()
values = student.values()
items = student.items()
```

### 辞書内包表記

```python
# 基本
squares = {x: x**2 for x in range(5)}
# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# 条件付き
even_squares = {x: x**2 for x in range(10) if x % 2 == 0}

# 2つのリストから辞書を作成
keys = ['name', 'age', 'city']
values = ['田中', 25, '東京']
person = dict(zip(keys, values))
```

---

## set（集合型）

重複のない要素の集まりを扱う型です。順序は保持されません。

### 基本的な使い方

```python
# 基本
numbers = {1, 2, 3, 4, 5}
fruits = {"りんご", "バナナ", "みかん"}

# 重複は自動的に削除される
unique = {1, 2, 2, 3, 3, 3}  # {1, 2, 3}

# リストから作成
numbers = set([1, 2, 3, 2, 1])  # {1, 2, 3}

# 空のセット
empty = set()
```

### 追加・削除

```python
fruits = {"りんご", "バナナ"}

# 追加
fruits.add("みかん")

# 複数追加
fruits.update(["いちご", "ぶどう"])

# 削除
fruits.remove("バナナ")  # 存在しないとKeyError
fruits.discard("バナナ")  # 存在しなくてもエラーなし

# すべて削除
fruits.clear()
```

### 集合演算

```python
a = {1, 2, 3, 4}
b = {3, 4, 5, 6}

# 和集合（どちらかに含まれる）
union = a | b  # {1, 2, 3, 4, 5, 6}

# 積集合（両方に含まれる）
intersection = a & b  # {3, 4}

# 差集合（aにあってbにない）
difference = a - b  # {1, 2}

# 対称差（どちらか一方にだけ含まれる）
sym_diff = a ^ b  # {1, 2, 5, 6}
```

### 実用例

```python
# 重複削除
numbers = [1, 2, 2, 3, 3, 3, 4, 5]
unique = list(set(numbers))  # [1, 2, 3, 4, 5]

# 共通要素の検索
list1 = [1, 2, 3, 4]
list2 = [3, 4, 5, 6]
common = set(list1) & set(list2)  # {3, 4}
```

---

## bool（ブール型）

真偽値を扱う型です。`True`か`False`の2値のみです。

### 基本的な使い方

```python
# 基本
is_active = True
is_finished = False

# 比較演算の結果
is_adult = age >= 18
is_equal = name == "田中"

# 論理演算
result = True and False  # False
result = True or False   # True
result = not True        # False
```

### 比較演算子

```python
# 等価・不等価
10 == 10  # True
10 != 5   # True

# 大小比較
10 > 5    # True
10 >= 10  # True

# 複数条件
x = 15
10 < x < 20  # True
```

### 真偽値への変換

```python
# 数値
bool(0)      # False
bool(1)      # True

# 文字列
bool("")     # False（空文字列）
bool("Hello") # True

# コレクション
bool([])     # False（空のリスト）
bool([1, 2]) # True
bool({})     # False（空の辞書）

# None
bool(None)   # False
```

---

## 型変換と注意点

### 基本的な型変換

```python
# 文字列 → 整数
age = int("25")  # 25

# 文字列 → 浮動小数点数
price = float("99.99")  # 99.99

# 数値 → 文字列
text = str(123)  # "123"

# リスト → セット（重複削除）
numbers = [1, 2, 2, 3]
unique = set(numbers)  # {1, 2, 3}

# 文字列 → リスト
chars = list("abc")  # ['a', 'b', 'c']

# リスト → 文字列
text = "".join(['a', 'b', 'c'])  # "abc"
```

### 型チェック

```python
# isinstance関数（推奨）
isinstance(10, int)  # True
isinstance(10, (int, float))  # True
isinstance("text", str)  # True
```

---

## まとめ：データ型選択ガイド

### 用途別の選び方

| データ型 | 使用場面 | 変更可能 | 順序 | 重複 |
|---------|---------|---------|------|------|
| **int** | カウント、ID | - | - | - |
| **float** | 価格、距離 | - | - | - |
| **str** | テキスト | ❌ | ✅ | ✅ |
| **list** | 動的なコレクション | ✅ | ✅ | ✅ |
| **tuple** | 固定データ | ❌ | ✅ | ✅ |
| **dict** | キーと値のペア | ✅ | ✅* | キー:❌ |
| **set** | 重複排除 | ✅ | ❌ | ❌ |
| **bool** | フラグ、条件 | - | - | - |

*Python 3.7+では順序を保持

### ベストプラクティス

```python
# ✅ 推奨
- f-stringを使う
- dict.get()でデフォルト値を設定
- is演算子でNoneをチェック
- リスト内包表記を活用
- 変更不要ならtupleを使う

# ❌ 非推奨
- 古いフォーマット方法
- KeyErrorを無視
- ==でNoneをチェック
- ループ中にリストを変更
```

実際にコードを書いて、データ型の特性を体感してみてください！

---

**参考リンク**
- [Python公式ドキュメント - 組み込み型](https://docs.python.org/ja/3/library/stdtypes.html)


#======================================
"""
====================================
🐰 Python継承 完全ガイド
実行可能なサンプルコード
====================================

このコードをコピーして実行すると、
3種類の継承が学べます！
"""

print("="*70)
print("🐰 Python継承の学習を始めます！")
print("="*70)
print()

# ====================================
# 第1部: 単一継承
# ====================================
print("\n" + "="*70)
print("【第1部】単一継承 - 1つの親から1つの子へ")
print("="*70)

# --------------------------------------------------
# ステップ1: 親クラスを定義
# --------------------------------------------------
class DaifukuShop:
    """
    大福店の基本クラス（親クラス）
    
    役割: すべての大福店の基本機能を提供
    """
    
    def __init__(self, owner_name, stock):
        """
        コンストラクタ - インスタンス作成時に自動実行される
        
        引数:
            owner_name (str): 店長の名前
            stock (int): 初期在庫数
        
        処理:
            1. 店長名をインスタンス変数に保存
            2. 在庫数をインスタンス変数に保存
            3. 累計販売数を0で初期化
        """
        # self = このインスタンス（このお店）自身を指す
        # self.変数名 = インスタンス変数（このお店専用の変数）
        self.owner_name = owner_name  # 引数の値をインスタンス変数に代入
        self.stock = stock            # 在庫数を保存
        self.sold = 0                 # 販売数は0から開始
        
        # 開店メッセージを表示
        print(f"🏪 {self.owner_name}店長の基本店舗を開店しました")
    
    def sell(self, quantity):
        """
        大福を販売するメソッド（親クラスの基本機能）
        
        引数:
            quantity (int): 販売する個数
        
        戻り値:
            bool: 販売成功ならTrue、失敗ならFalse
        
        処理:
            1. 在庫が足りるかチェック
            2. 足りなければFalseを返して終了
            3. 足りれば在庫を減らす
            4. 累計販売数を増やす
            5. Trueを返す
        """
        # if文で条件分岐
        # quantity > self.stock = 売る個数が在庫より多い
        if quantity > self.stock:
            # 在庫不足の場合
            print(f"❌ 在庫不足！（在庫: {self.stock}個、注文: {quantity}個）")
            return False  # Falseを返して関数を終了
        
        # 在庫を減らす
        # -= は「引き算して代入」の演算子
        # self.stock = self.stock - quantity と同じ意味
        self.stock -= quantity
        
        # 累計販売数を増やす
        # += は「足し算して代入」の演算子
        self.sold += quantity
        
        # 販売成功メッセージ
        print(f"💰 {quantity}個販売しました（残り在庫: {self.stock}個）")
        
        # 成功を示すTrueを返す
        return True
    
    def show_info(self):
        """
        店舗情報を表示するメソッド
        
        戻り値: なし
        
        処理:
            店長名、在庫数、累計販売数を表示
        """
        print(f"\n{'='*50}")
        print(f"🏪 店舗情報")
        print(f"   店長: {self.owner_name}")
        print(f"   在庫: {self.stock}個")
        print(f"   累計販売: {self.sold}個")
        print(f"{'='*50}\n")


# --------------------------------------------------
# ステップ2: 子クラスを定義（継承）
# --------------------------------------------------
class PremiumDaifukuShop(DaifukuShop):
    """
    プレミアム大福店クラス（子クラス）
    
    継承: DaifukuShopを継承
    構文: class 子クラス名(親クラス名):
    
    役割: 基本店舗の機能 + プレミアム機能
    """
    
    def __init__(self, owner_name, stock, vip_count):
        """
        コンストラクタ（子クラス版）
        
        引数:
            owner_name (str): 店長名
            stock (int): 初期在庫
            vip_count (int): VIP会員数（子クラス固有の引数）
        
        処理:
            1. 親クラスの__init__を呼び出す
            2. 子クラス固有の変数を初期化
        
        重要: super().__init__()を呼ばないと親の初期化がされない！
        """
        # super() = 親クラスを参照する特殊な関数
        # super().__init__() = 親クラスの__init__を呼び出す
        # これで owner_name, stock, sold が初期化される
        super().__init__(owner_name, stock)
        
        # 子クラス固有のインスタンス変数を追加
        # 親にはない、プレミアム店だけの情報
        self.vip_count = vip_count
        
        # プレミアム店舗のメッセージ
        print(f"✨ プレミアム機能追加（VIP会員: {vip_count}名）")
    
    def sell_premium(self, quantity):
        """
        プレミアム販売（子クラス固有のメソッド）
        
        特徴: 通常価格の1.5倍で販売
        
        引数:
            quantity (int): 販売個数
        
        戻り値:
            bool: 販売成功ならTrue
        
        処理:
            1. 親のsellメソッドを呼び出す
            2. 成功したらプレミアム価格を表示
        """
        # 親クラスのsellメソッドを呼び出す
        # super().メソッド名() = 親のメソッドを使う
        result = super().sell(quantity)
        
        # if result: = resultがTrueなら実行
        if result:
            # プレミアム価格を計算
            # 150円 × 1.5 = 225円
            premium_price = quantity * 225
            
            # プレミアム販売メッセージ
            print(f"✨ プレミアム価格: ¥{premium_price}")
        
        # 結果を返す（TrueまたはFalse）
        return result
    
    def add_vip(self, count=1):
        """
        VIP会員を追加（子クラス固有のメソッド）
        
        引数:
            count (int): 追加する会員数（デフォルト値は1）
        
        デフォルト引数: count=1 という書き方
            呼び出し時に引数を省略すると1が使われる
        """
        # VIP会員数を増やす
        self.vip_count += count
        
        # 追加メッセージ
        print(f"👑 VIP会員が{count}名増えました（合計: {self.vip_count}名）")
    
    def show_info(self):
        """
        店舗情報を表示（オーバーライド）
        
        オーバーライド: 親のメソッドを子で上書きすること
        
        処理:
            1. 親のshow_infoを呼んで基本情報を表示
            2. 子クラス固有のVIP情報を追加表示
        """
        # 親クラスのshow_infoを呼び出す
        # これで店長名、在庫、販売数が表示される
        super().show_info()
        
        # 子クラス固有の情報を追加
        print(f"👑 VIP会員: {self.vip_count}名")
        print(f"{'='*50}\n")


# --------------------------------------------------
# ステップ3: 単一継承を使ってみる
# --------------------------------------------------
print("\n【デモ1】親クラスを使う")
print("-"*70)

# 親クラスのインスタンスを作成
# クラス名(引数) でインスタンス化
basic = DaifukuShop("うさうさ", 20)
# 出力: 🏪 うさうさ店長の基本店舗を開店しました

# 親クラスのメソッドを呼び出す
basic.sell(5)
# 出力: 💰 5個販売しました（残り在庫: 15個）

# 情報表示
basic.show_info()

print("\n【デモ2】子クラスを使う")
print("-"*70)

# 子クラスのインスタンスを作成
# 引数3つ必要: owner_name, stock, vip_count
premium = PremiumDaifukuShop("もちもち", 30, 5)
# 出力: 🏪 もちもち店長の基本店舗を開店しました
#       ✨ プレミアム機能追加（VIP会員: 5名）

# 親から継承したメソッドを使う
premium.sell(3)
# 出力: 💰 3個販売しました（残り在庫: 27個）

# 子クラス固有のメソッドを使う
premium.sell_premium(2)
# 出力: 💰 2個販売しました（残り在庫: 25個）
#       ✨ プレミアム価格: ¥450

# VIP会員を追加
premium.add_vip(2)
# 出力: 👑 VIP会員が2名増えました（合計: 7名）

# オーバーライドしたメソッドを使う
premium.show_info()


# ====================================
# 第2部: 階層継承
# ====================================
print("\n" + "="*70)
print("【第2部】階層継承 - 親→子→孫と続く継承")
print("="*70)

# --------------------------------------------------
# 孫クラスを定義（階層継承）
# --------------------------------------------------
class VIPDaifukuShop(PremiumDaifukuShop):
    """
    VIP専門大福店クラス（孫クラス）
    
    継承: PremiumDaifukuShopを継承
    継承チェーン: DaifukuShop → PremiumDaifukuShop → VIPDaifukuShop
    
    役割: プレミアム店舗の機能 + VIP専門機能
    
    注意: 父を継承すると、自動的に祖父も継承される
    """
    
    def __init__(self, owner_name, stock, vip_count, concierge_count):
        """
        コンストラクタ（孫クラス版）
        
        引数:
            owner_name (str): 店長名
            stock (int): 初期在庫
            vip_count (int): VIP会員数
            concierge_count (int): コンシェルジュ数（孫クラス固有）
        
        処理:
            1. 父クラス(PremiumDaifukuShop)の__init__を呼ぶ
               → その中で祖父クラス(DaifukuShop)の__init__も呼ばれる
            2. 孫クラス固有の変数を初期化
        
        継承の連鎖:
            孫のsuper().__init__()
            → 父のsuper().__init__()
            → 祖父の__init__()
            全部自動的に実行される！
        """
        # super()で父クラス(PremiumDaifukuShop)の__init__を呼ぶ
        # 父の中で祖父の__init__も呼ばれるので、3世代全部初期化される
        super().__init__(owner_name, stock, vip_count)
        
        # 孫クラス固有のインスタンス変数
        self.concierge_count = concierge_count
        
        # VIP専門店のメッセージ
        print(f"👑 VIP専門店機能追加（コンシェルジュ: {concierge_count}名）")
    
    def sell_vip_exclusive(self, quantity):
        """
        VIP限定販売（孫クラス固有のメソッド）
        
        特徴: プレミアム価格の2倍（超高級）
        
        引数:
            quantity (int): 販売個数
        
        戻り値:
            bool: 販売成功ならTrue
        
        処理:
            1. 父のsell_premiumメソッドを呼ぶ
               → その中で祖父のsellメソッドも呼ばれる
            2. 成功したらVIP限定価格を表示
        """
        # 父クラス(PremiumDaifukuShop)のsell_premiumを呼ぶ
        # sell_premiumの中で祖父のsellが呼ばれる
        # つまり: 孫 → 父 → 祖父 のメソッド連鎖
        result = super().sell_premium(quantity)
        
        # 販売に成功した場合
        if result:
            # VIP限定価格を計算
            # 225円 × 2 = 450円
            vip_price = quantity * 450
            
            # VIP限定販売メッセージ
            print(f"👑 VIP限定価格: ¥{vip_price}")
            print(f"📞 コンシェルジュがお届けします")
        
        # 結果を返す
        return result
    
    def concierge_service(self):
        """
        コンシェルジュサービス（孫クラス固有のメソッド）
        
        処理:
            サービス内容を表示
        """
        print(f"\n👔 コンシェルジュサービス")
        print(f"   専任スタッフ: {self.concierge_count}名")
        print(f"   VIP会員様: {self.vip_count}名")
        print(f"   お一人様あたり専任コンシェルジュが対応します\n")
    
    def show_info(self):
        """
        店舗情報を表示（さらにオーバーライド）
        
        処理:
            1. 父のshow_infoを呼ぶ
               → 父の中で祖父のshow_infoも呼ばれる
            2. 孫クラス固有の情報を追加
        """
        # 父クラスのshow_infoを呼ぶ
        # これで祖父+父の情報が全部表示される
        super().show_info()
        
        # 孫クラス固有の情報を追加
        print(f"👔 コンシェルジュ: {self.concierge_count}名")
        print(f"{'='*50}\n")


# --------------------------------------------------
# 階層継承を使ってみる
# --------------------------------------------------
print("\n【デモ3】孫クラスを使う")
print("-"*70)

# 孫クラスのインスタンスを作成
# 引数4つ必要: owner_name, stock, vip_count, concierge_count
vip = VIPDaifukuShop("ぴょんぴょん", 40, 10, 3)
# 出力: 🏪 ぴょんぴょん店長の基本店舗を開店しました
#       ✨ プレミアム機能追加（VIP会員: 10名）
#       👑 VIP専門店機能追加（コンシェルジュ: 3名）

# 祖父クラスから継承したメソッド
vip.sell(2)

# 父クラスから継承したメソッド
vip.sell_premium(3)
vip.add_vip(1)

# 孫クラス固有のメソッド
vip.sell_vip_exclusive(1)
vip.concierge_service()

# オーバーライドしたメソッド（全情報表示）
vip.show_info()

# 継承チェーンを確認
print("【継承チェーン（MRO: Method Resolution Order）】")
print("メソッドを探す順番:")
# __mro__ = メソッド解決順序を示すタプル
# クラス.__mro__ で継承の順序がわかる
for i, cls in enumerate(VIPDaifukuShop.__mro__, 1):
    # enumerate(リスト, 開始番号) = インデックス付きでループ
    # cls.__name__ = クラス名を取得
    print(f"  {i}. {cls.__name__}")
# 出力: VIPDaifukuShop → PremiumDaifukuShop → DaifukuShop → object
print()


# ====================================
# 第3部: 多重継承
# ====================================
print("\n" + "="*70)
print("【第3部】多重継承 - 複数の親クラスから機能を組み合わせ")
print("="*70)

# --------------------------------------------------
# 4つの独立した親クラスを定義
# --------------------------------------------------

# 親クラスA: 基本店舗機能
class ShopBase:
    """
    店舗の基本機能（多重継承用の親A）
    
    役割: 店舗としての基本的な販売機能
    """
    
    def __init__(self, owner_name, stock):
        """
        コンストラクタ（親A）
        
        引数:
            owner_name (str): 店長名
            stock (int): 在庫数
        """
        self.owner_name = owner_name
        self.stock = stock
        self.sold = 0
        print(f"🏪 店舗機能: {owner_name}店長")
    
    def sell(self, quantity):
        """基本的な販売処理"""
        if quantity > self.stock:
            print(f"❌ 在庫不足")
            return False
        self.stock -= quantity
        self.sold += quantity
        print(f"💰 {quantity}個販売")
        return True


# 親クラスB: オンライン機能
class OnlineServiceMixin:
    """
    オンライン注文機能（多重継承用の親B）
    
    役割: オンラインでの注文受付機能
    
    Mixin: 機能追加専用のクラス
           単独では使わず、他のクラスと組み合わせて使う
    """
    
    def __init__(self):
        """
        コンストラクタ（親B）
        
        注意: 引数なし（機能だけを提供）
        """
        self.online_orders = 0  # オンライン注文の累計
        print(f"🌐 オンライン機能: システム起動")
    
    def receive_online_order(self, customer, quantity):
        """
        オンライン注文を受け付ける
        
        引数:
            customer (str): 顧客名
            quantity (int): 注文個数
        """
        self.online_orders += 1
        print(f"🌐 オンライン注文 #{self.online_orders}")
        print(f"   顧客: {customer}様、数量: {quantity}個")


# 親クラスC: 配達機能
class DeliveryServiceMixin:
    """
    配達サービス機能（多重継承用の親C）
    
    役割: 商品の配達機能
    """
    
    def __init__(self):
        """コンストラクタ（親C）"""
        self.deliveries = 0  # 配達の累計回数
        print(f"🚚 配達機能: サービス開始")
    
    def deliver(self, address):
        """
        商品を配達する
        
        引数:
            address (str): 配達先住所
        """
        self.deliveries += 1
        print(f"🚚 配達 #{self.deliveries}: {address}へ配達中")


# 親クラスD: 会員機能
class MembershipServiceMixin:
    """
    会員サービス機能（多重継承用の親D）
    
    役割: 会員の登録と管理
    """
    
    def __init__(self):
        """コンストラクタ（親D）"""
        self.members = []  # 会員名のリスト
        print(f"💳 会員機能: システム起動")
    
    def register_member(self, name):
        """
        会員を登録する
        
        引数:
            name (str): 会員名
        """
        # append() = リストに要素を追加するメソッド
        self.members.append(name)
        # len() = リストの長さを取得する関数
        print(f"💳 {name}様を会員登録（会員数: {len(self.members)}名）")
    
    def is_member(self, name):
        """
        会員かどうかチェック
        
        引数:
            name (str): チェックする名前
        
        戻り値:
            bool: 会員ならTrue
        """
        # in演算子 = リストに要素が含まれているかチェック
        return name in self.members


# --------------------------------------------------
# 子クラス: 多重継承で4つの機能を統合
# --------------------------------------------------
class HybridDaifukuShop(ShopBase, OnlineServiceMixin, 
                        DeliveryServiceMixin, MembershipServiceMixin):
    """
    ハイブリッド大福店（多重継承）
    
    継承元（カッコ内に複数の親をカンマ区切りで列挙）:
    - ShopBase（店舗機能）
    - OnlineServiceMixin（オンライン機能）
    - DeliveryServiceMixin（配達機能）
    - MembershipServiceMixin（会員機能）
    
    役割: すべての機能を統合した最先端店舗
    
    多重継承の構文:
        class 子クラス名(親A, 親B, 親C, 親D):
    
    注意点:
        - 全ての親を初期化する必要がある
        - super()だけでは不十分（複数親なので）
        - 親名.__init__(self, ...) の形式で直接呼ぶ
    """
    
    def __init__(self, owner_name, stock):
        """
        コンストラクタ（多重継承版）
        
        引数:
            owner_name (str): 店長名
            stock (int): 初期在庫
        
        重要: すべての親クラスを初期化する必要がある！
              一つでも忘れるとその機能が使えない
        """
        # 開始メッセージ
        print(f"\n{'='*60}")
        print(f"🌟 ハイブリッド店舗を起動中...")
        print(f"{'='*60}")
        
        # 各親クラスを初期化（順番に呼び出す）
        # 親クラス名.__init__(self, 引数) の形式
        # super()じゃなくて親名.__init__()を使う理由:
        #   複数の親があるので、どの親か明示する必要がある
        
        ShopBase.__init__(self, owner_name, stock)  # 親A初期化
        OnlineServiceMixin.__init__(self)  # 親B初期化
        DeliveryServiceMixin.__init__(self)  # 親C初期化
        MembershipServiceMixin.__init__(self)  # 親D初期化
        
        # 完了メッセージ
        print(f"✅ すべての機能が利用可能です")
        print(f"{'='*60}\n")
    
    def process_order(self, customer, quantity, address, is_member=False):
        """
        統合注文処理（すべての機能を組み合わせ）
        
        処理の流れ:
        1. オンライン注文受付（親Bの機能）
        2. 販売処理（親Aの機能）
        3. 配達処理（親Cの機能）
        4. 会員登録（親Dの機能）
        
        引数:
            customer (str): 顧客名
            quantity (int): 注文個数
            address (str): 配達先住所
            is_member (bool): 会員かどうか（デフォルトFalse）
        
        デフォルト引数: is_member=False
            呼び出し時に省略すると False が使われる
        """
        # 処理開始メッセージ
        print(f"\n{'='*60}")
        print(f"📝 注文処理開始: {customer}様")
        print(f"{'='*60}")
        
        # 1. オンライン注文受付（親Bのメソッド）
        # self.receive_online_order() = 親Bから継承したメソッド
        self.receive_online_order(customer, quantity)
        
        # 2. 販売処理（親Aのメソッド）
        # self.sell() = 親Aから継承したメソッド
        if self.sell(quantity):
            # 販売成功の場合
            
            # 3. 配達処理（親Cのメソッド）
            # self.deliver() = 親Cから継承したメソッド
            self.deliver(address)
            
            # 4. 会員登録処理（親Dのメソッド）
            # is_memberがTrueで、まだ登録されていない場合
            # and演算子 = 両方Trueなら実行
            # not演算子 = Trueの否定（Falseにする）
            if is_member and not self.is_member(customer):
                # self.register_member() = 親Dから継承したメソッド
                self.register_member(customer)
            
            # 成功メッセージ
            print(f"✅ 注文処理完了")
        else:
            # 販売失敗の場合
            print(f"❌ 注文処理失敗")
        
        # 処理終了メッセージ
        print(f"{'='*60}\n")
    
    def show_all_stats(self):
        """
        すべての統計情報を表示
        
        処理:
            4つの親から継承した全変数を表示
        """
        print(f"\n{'='*60}")
        print(f"📊 ハイブリッド店舗 総合統計")
        print(f"{'='*60}")
        
        # 店舗情報（親Aから継承した変数）
        print(f"🏪 店長: {self.owner_name}")
        print(f"📦 在庫: {self.stock}個")
        print(f"💰 累計販売: {self.sold}個")
        
        # オンライン情報（親Bから継承した変数）
        print(f"🌐 オンライン注文: {self.online_orders}件")
        
        # 配達情報（親Cから継承した変数）
        print(f"🚚 配達回数: {self.deliveries}回")
        
        # 会員情報（親Dから継承した変数）
        print(f"💳 会員数: {len(self.members)}名")
        
        # 区切り線
        print(f"{'='*60}\n")


# --------------------------------------------------
# 多重継承を使ってみる
# --------------------------------------------------
print("\n【デモ4】多重継承 - ハイブリッド店舗")
print("-"*70)
hybrid = HybridDaifukuShop("ふわふわ", 50)



# MRO（メソッド探索順）を確認
print("\n【MRO確認】")
for i, cls in enumerate(HybridDaifukuShop.__mro__, 1):
    print(f"  {i}. {cls.__name__}")
    

とても良いテーマです！🌱
新人エンジニアがつまずきやすいポイントでもある
`__init__` と `super()`、そして「特殊メソッド（ダンダーメソッド）」を
**やさしく・シンプルなコード付きで**解説しますね。

---

# 🐰 Pythonクラス基礎：「**init**」「super()」と特殊メソッドまとめ

---

## 🪄 1. `__init__`とは？（コンストラクタ）

### 💬 意味：

* クラスから**オブジェクトを作るときに自動で呼ばれる特別なメソッド**。
* 「初期設定（初期化）」をするために使います。

### 🔹 シンプルな例：

```python
class Animal:
    def __init__(self, name):
        self.name = name  # インスタンス変数に代入
        print(f"{self.name} が生まれました！")

dog = Animal("ポチ")  # => 「ポチ が生まれました！」
```

📘 ポイント：

* `__init__` は **「初期化の魔法」**
* `self` は「自分自身（作られたオブジェクト）」を表す。

---

## 🧩 2. `super()`とは？（親クラスを呼び出す）

### 💬 意味：

* **親クラスのメソッドを呼び出す**ための関数。
* 子クラスで上書き（オーバーライド）しても、
  親の処理を一部使いたいときに便利！

### 🔹 例：

```python
class Animal:
    def __init__(self, name):
        self.name = name
        print(f"{self.name} が生まれました！")

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # ← 親クラス(Animal)の__init__を呼ぶ
        self.breed = breed
        print(f"{self.breed} の犬です。")

dog = Dog("ポチ", "柴犬")
```

🪄 実行結果：

```
ポチ が生まれました！
柴犬 の犬です。
```

📘 ポイント：

* `super()` を使うと、親クラスの処理を再利用できる。
* Pythonの多重継承でも安全に動く（`super()`は順序を自動で判断する）。

---

## ⚙️ 3. 特殊メソッド（ダンダーメソッド）一覧

`__init__` のように、前後に「__（ダブルアンダースコア）」が付いている
メソッドを **「特殊メソッド（magic method / dunder method）」** と呼びます。

| メソッド名         | タイミング・役割              | 例                 |
| ------------- | --------------------- | ----------------- |
| `__init__`    | オブジェクト生成時に呼ばれる（初期化）   | `obj = MyClass()` |
| `__str__`     | `print()` で文字列表示するとき  | `print(obj)`      |
| `__repr__`    | 対話モードや`repr()`で表示     | `repr(obj)`       |
| `__len__`     | `len(obj)` で呼ばれる      | `len(obj)`        |
| `__getitem__` | `obj[key]` の取得時       | `obj["name"]`     |
| `__setitem__` | `obj[key] = value` の時 | 代入操作              |
| `__delitem__` | `del obj[key]` の時     | 削除操作              |
| `__iter__`    | 反復（forループ）開始時         | `for x in obj:`   |
| `__next__`    | 次の要素を取得する             | `next(iterator)`  |
| `__call__`    | オブジェクトを関数のように呼ぶ       | `obj()`           |
| `__eq__`      | `==` 比較               | `obj1 == obj2`    |
| `__lt__`      | `<` 比較                | `obj1 < obj2`     |
| `__add__`     | `+` 演算                | `obj1 + obj2`     |
| `__del__`     | オブジェクト削除時             | `del obj`         |

---

## 🧠 4. 特殊メソッドの動作例（ミニデモ）

```python
class Cat:
    def __init__(self, name):
        self.name = name

    def __str__(self):   # print()時の見た目
        return f"猫の名前は {self.name} です。"

    def __len__(self):   # len()対応
        return len(self.name)

cat = Cat("ミケ")
print(cat)        # => 猫の名前は ミケ です。
print(len(cat))   # => 2（文字数）
```

---

## 🪶 5. まとめ

| キーワード      | 役割               | よく使う場面                     |
| ---------- | ---------------- | -------------------------- |
| `__init__` | 初期化メソッド          | オブジェクト生成時に実行される            |
| `super()`  | 親クラスの呼び出し        | 継承時の再利用                    |
| 特殊メソッド     | Python組み込み動作を上書き | `print()`, `len()`, 比較演算など |

---

💬 **ポイント：**

* `__init__` は「作るときの最初の設定」。
* `super()` は「親の力を借りる魔法」。
* 特殊メソッドは「Pythonが裏で呼んでくれる秘密の仕組み」。

---

希望があれば次に、
👉 `__str__`, `__repr__`, `__add__` を使って
**「自作クラスをprintや+演算で使えるようにする」実践例**を作ります。

作ってみましょうか？


＃＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

よしきましたね！🐍✨
それでは、**「自作クラスを `print()` や `+` 演算で使えるようにする」**
特殊メソッド活用の実践編を見ていきましょう。

---

# 🧁 Python実践：「**str**」「**repr**」「**add**」を使ってみよう！

---

## 🎀 1. 目標

ふわふわ大福屋さんをテーマにして、
「**大福クラス**」を作ります。

* `print()` したらかわいく紹介してくれる 🍡
* `+` で新しい味を合体できる 🍓
* `repr()` でデバッグに便利な情報を出す 🧩

---

## 🧩 2. コード例

```python
class Daifuku:
    def __init__(self, flavor, price):
        self.flavor = flavor
        self.price = price

    def __str__(self):
        """print() で人に見せる用（ユーザー向け）"""
        return f"🍡 {self.flavor}大福 - {self.price}円"

    def __repr__(self):
        """repr() やデバッグ表示用（開発者向け）"""
        return f"Daifuku(flavor='{self.flavor}', price={self.price})"

    def __add__(self, other):
        """+ 演算子で新しい大福を合体！"""
        new_flavor = f"{self.flavor}×{other.flavor}"
        new_price = self.price + other.price
        return Daifuku(new_flavor, new_price)
```

---

## 🍓 3. 使い方

```python
a = Daifuku("いちご", 150)
b = Daifuku("抹茶", 180)

print(a)         # 🍡 いちご大福 - 150円
print(repr(a))   # Daifuku(flavor='いちご', price=150)

c = a + b        # 合体！
print(c)         # 🍡 いちご×抹茶大福 - 330円
```

---

## 🧠 4. 特殊メソッドのイメージ図

| メソッド       | 役割         | Pythonの呼び出しタイミング   | 対象     |
| ---------- | ---------- | ------------------ | ------ |
| `__str__`  | 見た目を整える    | `print(obj)`       | ユーザー   |
| `__repr__` | デバッグ用の再現表示 | `repr(obj)`、REPL環境 | 開発者    |
| `__add__`  | 加算演算を定義    | `obj1 + obj2`      | カスタム動作 |

---

## 💬 5. 補足：`__repr__` の設計ポイント

`__repr__` は「**開発者が見たときに分かるように**」作るのがコツです。
公式ガイドラインには次のように書かれています👇

> `__repr__` は、可能であれば同じオブジェクトを再生成できる文字列を返すべき。

例：

```python
>>> Daifuku("いちご", 150)
Daifuku(flavor='いちご', price=150)
```

これなら、`eval("Daifuku(flavor='いちご', price=150)")` でも再現できます。

---

## 🌸 6. 応用アイデア（＋α）

もし自作クラスをもっとPythonらしくしたいなら、他にも：

| 特殊メソッド     | 意味               | 例        |
| ---------- | ---------------- | -------- |
| `__eq__`   | `==` 比較の定義       | `a == b` |
| `__lt__`   | `<` 比較の定義        | ソート対応    |
| `__len__`  | `len(obj)` で値を返す | 内容の長さなど  |
| `__call__` | オブジェクトを関数のように呼ぶ  | `obj()`  |

---

## 🎁 7. まとめ

| 項目         | 内容          | 用途         |
| ---------- | ----------- | ---------- |
| `__str__`  | 見やすい文字列を返す  | print時の見た目 |
| `__repr__` | 正確で再現可能な文字列 | デバッグやログ    |
| `__add__`  | 加算の定義       | カスタム演算     |

---

## 🐇 ふわふわ大福店のたとえ

| 概念         | たとえ              |
| ---------- | ---------------- |
| `__init__` | 大福を作るときの「仕込み」    |
| `__str__`  | お客様に見せる「メニュー表示」  |
| `__repr__` | 製造スタッフ向けの「レシピ番号」 |
| `__add__`  | 新商品を「合体」して作る試作品  |

---

もし希望があれば次に：
👉 `__eq__`, `__lt__`, `__len__` を使って
「**オブジェクトを比較・ソート・len対応**」する大福クラスも作れます。

作ってみましょうか？


"==============================




#=====================--
